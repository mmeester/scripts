---
title: Triggering Script Loading
---

Nuxt Scripts provides several ways to trigger the loading of scripts.

::code-group

```ts [useScript - Ref]
import { useTimeout } from '@vueuse/core'

const { ready } = useTimeout(3000)
useScript({
  src: 'https://example.com/script.js',
}, {
  // load however you like!
  trigger: ready, // refs supported
})
```

```ts [useScript - Computed]
const route = useRoute()
useScript({
  src: 'https://example.com/script.js',
}, {
  // only if route has a specific query
  trigger: computed(() => !!route.query.affiliateId),
})
```

```ts [Registry Script]
import { useTimeout } from '@vueuse/core'

const { ready } = useTimeout(3000)
useScriptMetaPixel({
  id: '1234567890',
  scriptOptions: {
    trigger: ready
  }
})
```

```ts [Global Script]
export default defineNuxtConfig({
  scripts: {
    globals: {
      myScript: ['https://example.com/script.js', {
        // load after page is fully interactive (idle loading)
        trigger: 'onNuxtReady'
      }]
    }
  }
})
```

::

## Default Behavior

By default, scripts are loaded when Nuxt is fully hydrated using the `onNuxtReady` trigger. This provides an "idle loading" behavior where scripts load only after the page is fully interactive, minimizing impact on Core Web Vitals and user experience.

The `onNuxtReady` trigger ensures scripts load:
- After Nuxt hydration is complete
- When the browser is idle and the main thread is available
- Without blocking critical page rendering or user interactions

This is more effective than using `defer` or `fetchpriority="low"` attributes alone, as it waits for the application to be fully ready rather than just the HTML parsing to complete.

You can change this default by modifying the [defaultScriptOptions](/docs/api/nuxt-config#defaultscriptoptions).

## Idle Loading with onNuxtReady

The `onNuxtReady` trigger is perfect for non-critical scripts like chat widgets, analytics, or marketing tools that should load with minimal performance impact:

```ts
// Chat widget - loads after page is fully interactive
useScript('https://widget.intercom.io/widget/abc123', {
  trigger: 'onNuxtReady' // default behavior
})

// Explicitly using onNuxtReady for clarity
useScriptGoogleAnalytics({
  id: 'GA_MEASUREMENT_ID',
  scriptOptions: {
    trigger: 'onNuxtReady'
  }
})
```

This approach ensures your Core Web Vitals remain optimal while still loading necessary third-party scripts.

## Element Event Triggers

The [useScriptTriggerElement](/docs/api/use-script-trigger-element) composable allows you to hook into element events as a way to load script. This is useful for loading scripts when a user interacts with a specific element.

```ts
const somethingEl = ref<HTMLElement>()
const script = useScript({
  src: 'https://example.com/script.js',
}, {
  trigger: useScriptTriggerElement({
    trigger: 'hover',
    el: somethingEl,
  })
})
```

It has support for the following triggers:
- `visible` - Triggered when the element becomes visible in the viewport.
- `mouseover` - Triggered when the element is hovered over.

## Manual Trigger

The `manual` trigger allows you to manually trigger the loading of a script. This gives you complete
control over when the script is loaded.

```ts
const { load } = useScript('https://example.com/script.js', {
  trigger: 'manual'
})
// ...
load()
```

## Promise

You can use a promise to trigger the loading of a script. This is useful for any other custom trigger you might want to use.

```ts
const myScript = useScript('/script.js', {
  // load after 3 seconds
  trigger: new Promise(resolve => setTimeout(resolve, 3000))
})
```

## Ref

You can use a ref to trigger the loading of a script. This is useful for any other custom trigger you might want to use.

```ts
const myRef = ref(false)
const myScript = useScript('/script.js', {
  trigger: myRef
})
// ...
myRef.value = true
```
